<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Glyphmon Circuit Prototyping</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html,body{margin:0;background:#0f1220;color:#eee;font-family:system-ui,Meiryo,sans-serif;}
  .wrap{display:grid;grid-template-columns:auto 200px;gap:8px;padding:8px;height:100vh;box-sizing:border-box;}
  .panel{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:8px;padding:8px;}
  #canvas{display:block;background:rgba(255,255,255,0.02);border-radius:8px;}
  .tool{user-select:none;background:#2b2f47;border:1px dashed rgba(255,255,255,0.3);border-radius:6px;padding:6px;margin-bottom:6px;display:flex;align-items:center;gap:6px;cursor:grab;}
  .icon{width:28px;height:28px;border-radius:6px;background:#ffd54f;color:#111;display:grid;place-items:center;font-weight:bold;}
  .hint{font-size:12px;opacity:.75}
</style>
</head>
<body>
<div class="wrap">
  <div>
    <div id="score" style="font-size:16px;margin-top:4px;">Score: 0.00</div>
    <canvas id="canvas"></canvas>
  </div>
  <div>
    <div class="panel">
      <div class="tool" draggable="true" data-item="#"><div class="icon">#</div><div>赤→青</div></div>
      <div class="tool" draggable="true" data-item="sync"><div class="icon">S</div><div>同期</div></div>
      <div class="tool" draggable="true" data-item="upsync"><div class="icon">↑</div><div>上流れ</div></div>
    </div>
  </div>
</div>

<script>
const cols=9,rows=9,cellSize=20;
const spawnInterval=3000,moveInterval=500,rollingWindowSec=10;
const canvas=document.getElementById("canvas"),ctx=canvas.getContext("2d");
canvas.width=cols*cellSize+40;
canvas.height=rows*cellSize+100;
const scoreEl=document.getElementById("score");

const ARROWS=['↑','→','↓','←',null];
const ARROW_DIRS={'→':{dx:1,dy:0},'↓':{dx:0,dy:1},'←':{dx:-1,dy:0},'↑':{dx:0,dy:-1}};
const grid=Array.from({length:rows},()=>Array.from({length:cols},()=>({arrow:null,element:null})));

const COLORS={red:{rgb:[255,70,70],v:-1},green:{rgb:[80,255,150],v:+1},blue:{rgb:[90,160,255],v:+1.5}};
const signals=[],scoreLog=[];
class Signal{
  constructor({x=0,y=0,color='red',number=1}){
    this.x=x;
    this.y=y;
    this.lastMove=0;
    this.active=true;
    this.paused=false;
    this.number=number;
    this.vx=0;
    this.vy=-1;
    this.color=color;
  }
  set color(name){
    const preset=COLORS[name];
    if(!preset)throw new Error(`Unknown color: ${name}`);
    this._color=name;
    this.rgb=preset.rgb.slice();
    this.v=preset.v;
  }
  get color(){
    return this._color;
  }
}
let inputStack=[]; // 左詰めで3つまで
function now(){return performance.now();}

/* syncシステム */
const pausedSyncSignals=[];
function onSyncHit(sig){
  if(pausedSyncSignals.length===0){sig.active=false;sig.paused=true;pausedSyncSignals.push(sig);return 'paused';}
  else{while(pausedSyncSignals.length){const s=pausedSyncSignals.pop();s.active=true;s.paused=false;}return'released';}
}

/* 移動 */
function applyElementsAndMoveInCell(cell,sig){
  if(cell.element==='#'&&sig.color==='red'){sig.color='blue';}
  if(cell.element==='upsync'){
    sig.vx=0;
    sig.vy=-1;
    sig.y-=1;
    return 'handled';
  }
  if(cell.arrow){
    const d=ARROW_DIRS[cell.arrow];
    if(d){sig.vx=d.dx;sig.vy=d.dy;}
  }
  sig.x+=sig.vx;
  sig.y+=sig.vy;
  if(cell.element==='sync'){
    const r=onSyncHit(sig);
    if(r==='paused')return 'paused';
  }
  return 'moved';
}
function move(sig,t){
  if(!sig.active||(t-sig.lastMove)<moveInterval)return;
  sig.lastMove=t;
  if(sig.y===rows){
    sig.y=rows-1;
    return;
  }
  if(sig.y>=0&&sig.y<rows&&sig.x>=0&&sig.x<cols){
    const c=grid[sig.y][sig.x];
    const result=applyElementsAndMoveInCell(c,sig);
    if(result==='handled'||result==='paused')return;
  }else{
    sig.x+=sig.vx;
    sig.y+=sig.vy;
  }
  if(sig.y<0){scoreLog.push({t,v:sig.v});sig.active=false;}
  if(sig.x<0||sig.x>=cols||sig.y>rows){sig.active=false;}
}

/* スコア */
function rollingScore(t){const c=t-rollingWindowSec*1000;while(scoreLog.length&&scoreLog[0].t<c)scoreLog.shift();
  return scoreLog.length?scoreLog.reduce((a,b)=>a+b.v,0)/scoreLog.length:0;}

/* スポーン */
function spawnSignal(){
  const n=['red','green','blue'][Math.floor(Math.random()*3)];
  const num=Math.floor(Math.random()*9)+1;
  if(inputStack.length<3){
    inputStack.push(new Signal({x:inputStack.length,y:rows+1,color:n,number:num}));
  }
}
/* スタック上げ */
function checkInputStackRelease(){
  if(inputStack.length===3){
    // 3つ集まったら全て上に移動
    for(let i=0;i<3;i++){
      const s=inputStack[i];
      s.y=rows; // input laneへ
      s.x=i;    // 左詰め
      s.vx=0;
      s.vy=-1;
      signals.push(s);
    }
    inputStack=[];
  }
}

/* 描画 */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const x0=20,yOut=20,yGrid=yOut+30,yIn=yGrid+rows*cellSize;
  const pointToCanvas=(px,py)=>{
    const cx=x0+px*cellSize+cellSize/2;
    if(py===rows+1)return{x:cx,y:yIn+20};
    if(py===rows)return{x:cx,y:yIn};
    if(py<0)return{x:cx,y:yOut};
    if(py>rows)return{x:cx,y:yIn+30};
    return{x:cx,y:yGrid+py*cellSize+cellSize/2};
  };
  ctx.fillStyle="rgba(255,70,70,0.2)";ctx.fillRect(x0,yOut,cols*cellSize,30);
  ctx.fillStyle="rgba(90,160,255,0.2)";ctx.fillRect(x0,yIn,cols*cellSize,30);
  ctx.strokeStyle="rgba(255,255,255,0.15)";
  for(let r=0;r<=rows;r++){ctx.beginPath();ctx.moveTo(x0,r*cellSize+yGrid+.5);ctx.lineTo(x0+cols*cellSize,r*cellSize+yGrid+.5);ctx.stroke();}
  for(let c=0;c<=cols;c++){ctx.beginPath();ctx.moveTo(x0+c*cellSize+.5,yGrid);ctx.lineTo(x0+c*cellSize+.5,yGrid+rows*cellSize);ctx.stroke();}
  ctx.textAlign="center";ctx.textBaseline="middle";ctx.font="bold 14px monospace";
  for(let y=0;y<rows;y++)for(let x=0;x<cols;x++){
    const cell=grid[y][x],cx=x0+x*cellSize+cellSize/2,cy=yGrid+y*cellSize+cellSize/2;
    if(cell.arrow){ctx.fillStyle="#fff";ctx.fillText(cell.arrow,cx,cy);}
    if(cell.element){ctx.fillStyle="#ffd54f";ctx.fillRect(cx-10,cy-10,20,20);ctx.fillStyle="#111";ctx.fillText(cell.element==='upsync'?'↑':cell.element==='sync'?'S':'#',cx,cy);}
  }
  // 矢印に基づく回路ライン
  ctx.save();
  ctx.lineWidth=3;
  ctx.lineJoin="round";
  ctx.lineCap="round";
  ctx.strokeStyle="rgba(180,180,200,0.45)";
  const advance=cellSize*0.5;
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const cell=grid[y][x];
      const dir=ARROW_DIRS[cell.arrow];
      if(!dir)continue;
      const start=pointToCanvas(x,y);
      const nx=x+dir.dx,ny=y+dir.dy;
      let end;
      if(ny>=0&&ny<rows&&nx>=0&&nx<cols){
        end=pointToCanvas(nx,ny);
      }else{
        end={x:start.x+dir.dx*advance,y:start.y+dir.dy*advance};
      }
      ctx.beginPath();
      ctx.moveTo(start.x,start.y);
      ctx.lineTo(end.x,end.y);
      ctx.stroke();
    }
  }
  ctx.restore();
  // 入力レーンからの経路を描画
  const simulatePathFromInput=x=>{
    const pts=[];
    let cxCell=x;
    let cyCell=rows;
    let dir={dx:0,dy:-1};
    const visited=new Set();
    const maxSteps=cols*rows*2;
    let loopDetected=false;
    const addPoint=(x,y)=>{
      const last=pts[pts.length-1];
      if(!last||last.rawX!==x||last.rawY!==y){
        const canvasPoint=pointToCanvas(x,y);
        canvasPoint.rawX=x;
        canvasPoint.rawY=y;
        pts.push(canvasPoint);
      }
    };
    addPoint(cxCell,cyCell);
    for(let step=0;step<maxSteps;step++){
      const state=`${cxCell},${cyCell},${dir.dx},${dir.dy}`;
      if(visited.has(state)){loopDetected=true;break;}
      visited.add(state);
      const nx=cxCell+dir.dx;
      const ny=cyCell+dir.dy;
      addPoint(nx,ny);
      cxCell=nx;
      cyCell=ny;
      if(ny<0||ny>rows||nx<0||nx>=cols)break;
      if(ny===rows){
        dir={dx:0,dy:-1};
        continue;
      }
      const cell=grid[ny][nx];
      if(cell&&cell.arrow){
        const d=ARROW_DIRS[cell.arrow];
        if(d){dir=d;}
      }
    }
    if(loopDetected&&pts.length>1)pts.pop();
    return pts;
  };
  ctx.save();
  ctx.lineWidth=3;
  ctx.lineJoin="round";
  ctx.lineCap="round";
  ctx.strokeStyle="rgba(160,160,170,0.6)";
  for(let x=0;x<cols;x++){
    const pts=simulatePathFromInput(x);
    if(pts.length<2)continue;
    ctx.beginPath();
    ctx.moveTo(pts[0].x,pts[0].y);
    for(let i=1;i<pts.length;i++){
      ctx.lineTo(pts[i].x,pts[i].y);
    }
    ctx.stroke();
  }
  ctx.restore();
  // 信号描画
  for(const s of [...signals,...inputStack]){
    if(!s.active&&!s.paused)continue;
    let cx=x0+s.x*cellSize+cellSize/2,cy;
    if(s.y===rows+1)cy=yIn+20; // スタック
    else if(s.y===rows)cy=yIn; // input lane上段
    else cy=yGrid+s.y*cellSize+cellSize/2;
    ctx.beginPath();
    ctx.fillStyle=`rgb(${s.rgb[0]},${s.rgb[1]},${s.rgb[2]})`;
    ctx.arc(cx,cy,7,0,Math.PI*2);ctx.fill();
    if(s.number!==undefined&&s.number!==null){
      ctx.fillStyle="#111";
      ctx.font="bold 10px monospace";
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillText(String(s.number),cx,cy);
    }
  }
}

/* 矢印クリック / D&D */
canvas.addEventListener("click",e=>{
  const r=canvas.getBoundingClientRect(),mx=(e.clientX-r.left)*canvas.width/r.width,my=(e.clientY-r.top)*canvas.height/r.height;
  const x0=20,yOut=20,yGrid=yOut+30;
  if(mx>=x0&&mx<x0+cols*cellSize&&my>=yGrid&&my<yGrid+rows*cellSize){
    const gx=Math.floor((mx-x0)/cellSize),gy=Math.floor((my-yGrid)/cellSize);
    grid[gy][gx].arrow=ARROWS[(ARROWS.indexOf(grid[gy][gx].arrow)+1)%ARROWS.length];
  }
});
const tools=document.querySelectorAll(".tool");
tools.forEach(t=>t.addEventListener("dragstart",e=>e.dataTransfer.setData("text/plain",t.dataset.item)));
canvas.addEventListener("dragover",e=>e.preventDefault());
canvas.addEventListener("drop",e=>{
  e.preventDefault();const item=e.dataTransfer.getData("text/plain");
  const r=canvas.getBoundingClientRect(),mx=(e.clientX-r.left)*canvas.width/r.width,my=(e.clientY-r.top)*canvas.height/r.height;
  const x0=20,yOut=20,yGrid=yOut+30;
  if(mx>=x0&&mx<x0+cols*cellSize&&my>=yGrid&&my<yGrid+rows*cellSize){
    const gx=Math.floor((mx-x0)/cellSize),gy=Math.floor((my-yGrid)/cellSize);grid[gy][gx].element=item;
  }
});

/* ループ */
let lastSpawn=0;
function loop(){
  const t=now();
  if(t-lastSpawn>spawnInterval){spawnSignal();lastSpawn=t;}
  checkInputStackRelease();
  for(const s of signals)move(s,t);
  for(let i=signals.length-1;i>=0;i--)if(!signals[i].active&&!signals[i].paused)signals.splice(i,1);
  draw();
  scoreEl.textContent="Score: "+rollingScore(t).toFixed(2);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
